<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Other Module</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="Fcitx Developer Handbook">
<link rel="up" href="part-module.html" title="Part V. Module">
<link rel="prev" href="article-event-module.html" title="Event Module">
<link rel="next" href="article-inter-module-function.html" title="Inter Module function call">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Other Module</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="article-event-module.html">Prev</a> </td>
<th width="60%" align="center">Part V. Module</th>
<td width="20%" align="right"> <a accesskey="n" href="article-inter-module-function.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="article" title="Other Module">
<div class="titlepage">
<div><div><h2 class="title">
<a name="article-other-module"></a>Other Module</h2></div></div>
<hr>
</div>
<p>
            Except Event based modules, all other misc module will use built-in
            hook to interference the key event processing.
        </p>
<p>
            Currently, there are following usable hooks to interference with key event
            processing.
        </p>
<pre class="programlisting">       
void RegisterPreInputFilter(struct _FcitxInstance* instance, KeyFilterHook) ;
void RegisterPostInputFilter(struct _FcitxInstance* instance, KeyFilterHook);
void RegisterOutputFilter(struct _FcitxInstance* instance, StringFilterHook);
void RegisterHotkeyFilter(struct _FcitxInstance* instance, HotkeyHook);
void RegisterResetInputHook(struct _FcitxInstance* instance, FcitxIMEventHook value);
void RegisterTriggerOnHook(struct _FcitxInstance* instance, FcitxIMEventHook value);
void RegisterTriggerOffHook(struct _FcitxInstance* instance, FcitxIMEventHook value);
void RegisterInputFocusHook(struct _FcitxInstance* instance, FcitxIMEventHook value);
void RegisterInputUnFocusHook(struct _FcitxInstance* instance, FcitxIMEventHook value);
void RegisterUpdateCandidateWordHook(struct _FcitxInstance* instance, FcitxIMEventHook value);
        </pre>
<p>
            As mentioned in Architecture before, the key event processing is separated into
            4 phases. PreInput are called before Input Method's DoInput function.
            PostInput will be called after Input Method's DoInput function, if the key event doesn't get processed yet.
        </p>
<p>
            Hotkey will be processed at last, but it will not be blocked even if input context
            state is ENG. That's the main difference to PreInput and PostInput. If an addon only have
            a status need to be toggled, it should use hotkey instead of Input Filter.
        </p>
<p>
            All input state will be set to default if ResetInput is called.
            Reset input is always usable via hotkey escape.
        </p>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="article-event-module.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="part-module.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="article-inter-module-function.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Event Module </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Inter Module function call</td>
</tr>
</table>
</div>
</body>
</html>
